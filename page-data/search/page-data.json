{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"IDE Intellij IntelliJ 단축키 정리 (Mac & Windows) 1️⃣ 기본 네비게이션 기능 Mac Windows 빠른 검색 (파일, 클래스, 심볼, 액션 검색)   파일 탐색기 열기 (프로젝트 창 토글)   최근 열었던 파일 보기   최근 편집한 파일 보기   클래스 찾기   파일 찾기   메서드 찾기   라인 이동 (특정 줄번호로 이동) …","fields":{"slug":"/20250310_ide/"},"frontmatter":{"date":"March 10, 2025","title":"💻 IntelliJ 단축키 정리 (Mac & Windows)","tags":["IntelliJ","단축키"]},"rawMarkdownBody":"\n## [IDE] Intellij\nIntelliJ 단축키 정리 (Mac & Windows)\n\n## 1️⃣ 기본 네비게이션\n\n| 기능 | Mac | Windows |\n|---|---|---|\n| 빠른 검색 (파일, 클래스, 심볼, 액션 검색) | `Shift + Shift` | `Shift + Shift` |\n| 파일 탐색기 열기 (프로젝트 창 토글) | `Cmd + 1` | `Alt + 1` |\n| 최근 열었던 파일 보기 | `Cmd + E` | `Ctrl + E` |\n| 최근 편집한 파일 보기 | `Cmd + Shift + E` | `Ctrl + Shift + E` |\n| 클래스 찾기 | `Cmd + O` | `Ctrl + N` |\n| 파일 찾기 | `Cmd + Shift + O` | `Ctrl + Shift + N` |\n| 메서드 찾기 | `Cmd + Alt + O` | `Ctrl + Alt + Shift + N` |\n| 라인 이동 (특정 줄번호로 이동) | `Cmd + L` | `Ctrl + G` |\n| 백 버튼 (이전 코드로 이동) | `Cmd + [` | `Ctrl + Alt + Left` |\n| 앞으로 이동 (이전 위치로 이동) | `Cmd + ]` | `Ctrl + Alt + Right` |\n\n\n\n## 2️⃣ 코드 편집\n\n| 기능 | Mac | Windows |\n|---|---|---|\n| 코드 자동 정렬 (Reformat Code) | `Cmd + Option + L` | `Ctrl + Alt + L` |\n| 자동 줄 맞춤 (Optimize Imports) | `Cmd + Option + O` | `Ctrl + Alt + O` |\n| 주석 토글 (라인 주석) | `Cmd + /` | `Ctrl + /` |\n| 블록 주석 토글 | `Cmd + Shift + /` | `Ctrl + Shift + /` |\n| 한 줄 삭제 | `Cmd + Backspace` | `Ctrl + Y` |\n| 줄 복사 (현재 줄을 복사 후 다음 줄에 붙여넣기) | `Cmd + D` | `Ctrl + D` |\n| 줄 이동 (위/아래) | `Option + Shift + ↑ / ↓` | `Shift + Alt + ↑ / ↓` |\n| 줄 병합 (다음 줄과 합치기) | `Cmd + Shift + J` | `Ctrl + Shift + J` |\n| 선택 영역 확장 | `Option + ↑` | `Ctrl + W` |\n| 선택 영역 축소 | `Option + ↓` | `Ctrl + Shift + W` |\n| 단어별 이동 (좌/우) | `Option + ← / →` | `Ctrl + ← / →` |\n| 행 단위로 이동 (페이지 업/다운) | `Cmd + ↑ / ↓` | `Ctrl + ↑ / ↓` |\n\n\n\n## 3️⃣ 코드 생성 및 리팩토링\n\n| 기능 | Mac | Windows |\n|---|---|---|\n| 자동 완성 (기본) | `Ctrl + Space` | `Ctrl + Space` |\n| 스마트 자동 완성 (타입 맞춤 자동완성) | `Cmd + Shift + Space` | `Ctrl + Shift + Space` |\n| 빠른 수정 (Show Intention Actions - Alt+Enter) | `Option + Enter` | `Alt + Enter` |\n| 메서드 구현 (Override/Implement Methods) | `Cmd + I` | `Ctrl + I` |\n| 메서드 정의로 이동 (Declaration) | `Cmd + B` | `Ctrl + B` |\n| 메서드 사용처 찾기 (Find Usages) | `Option + F7` | `Alt + F7` |\n| 변수 리팩토링 (변수명 변경) | `Shift + F6` | `Shift + F6` |\n| 메서드 추출 (Extract Method) | `Cmd + Option + M` | `Ctrl + Alt + M` |\n| 변수 추출 (Extract Variable) | `Cmd + Option + V` | `Ctrl + Alt + V` |\n| 필드 추출 (Extract Field) | `Cmd + Option + F` | `Ctrl + Alt + F` |\n| 상수 추출 (Extract Constant) | `Cmd + Option + C` | `Ctrl + Alt + C` |\n\n\n\n## 4️⃣ 실행 및 디버깅\n\n| 기능 | Mac | Windows |\n|---|---|---|\n| 코드 실행 | `Ctrl + R` | `Shift + F10` |\n| 디버그 실행 | `Ctrl + D` | `Shift + F9` |\n| 라인별 디버깅 중단점 추가/제거 | `Cmd + F8` | `Ctrl + F8` |\n| 디버깅 시 다음 중단점으로 이동 | `Cmd + Option + F8` | `Ctrl + Alt + F8` |\n| 디버깅 진행 (Step Over) | `F8` | `F8` |\n| 디버깅 진행 (Step Into) | `F7` | `F7` |\n| 디버깅 종료 | `Cmd + F2` | `Ctrl + F2` |\n\n\n\n## 5️⃣ Git / Version Control\n\n| 기능 | Mac | Windows |\n|---|---|---|\n| Git 창 열기 | `Cmd + 9` | `Alt + 9` |\n| 커밋 창 열기 | `Cmd + K` | `Ctrl + K` |\n| 푸시 (Push to Repository) | `Cmd + Shift + K` | `Ctrl + Shift + K` |\n| 체크아웃 (Checkout from Version Control) | `Cmd + T` | `Ctrl + T` |\n| 변경사항 확인 (Local Changes) | `Cmd + Shift + C` | `Ctrl + Shift + C` |\n| 버전 기록 보기 (Show History) | `Cmd + Shift + A` | `Ctrl + Shift + A` |\n\n\n\n## 6️⃣ 창 관리 및 설정\n\n| 기능 | Mac | Windows |\n|---|---|---|\n| 설정 (Preferences) | `Cmd + ,` | `Ctrl + Alt + S` |\n| 터미널 열기/닫기 | `Option + F12` | `Alt + F12` |\n| 파일 구조 보기 (Structure View) | `Cmd + 7` | `Ctrl + 7` |\n| 빠른 문서 보기 (Quick Documentation) | `F1` | `Ctrl + Q` |\n| 전체 화면 모드 전환 | `Cmd + Ctrl + F` | `Shift + Alt + Enter` |\n| 현재 창 닫기 | `Cmd + W` | `Ctrl + F4` |\n| 모든 창 닫기 | `Cmd + Shift + W` | `Ctrl + Shift + F4` |\n\n"},{"excerpt":"JPA란? Java Persistence API 자바 진영의 ORM 기술 표준 Object-Relational Mapping(객체 관계 매핑) 객체는 객체대로 설계 관계형 데이터베이스는 관계형 데이터베이스대로 설계 ORM 프레임워크가 중간에서 매핑 JPA를 사용하는 이유 SQL 중심 개발에서 객체 중심으로 개발 ORM이 중간에서 문제 해결 자바 객체 컬렉…","fields":{"slug":"/250205_JPA/"},"frontmatter":{"date":"February 05, 2025","title":"🌱 JPA란?","tags":["MSA","Microservice","Monolithic"]},"rawMarkdownBody":"\n## JPA란?\n\n```\n1. JPA는 개발자의 sql 쿼리 작업을 최소화 해준다.\n\n2. 컬럼 추가 시 쿼리문을 일괄 수정해야하는 상황을 해결해준다.\n\n3. CRUD 쿼리를 간단하게 생성할 수 있도록 도와준다\n\n4. 객체를 자바 컬렉션에 저장하 듯 DB에 저장하고자 하는 목적으로 만들어졌다.\n```\n\n## Java Persistence API\n\n**자바 진영의 ORM 기술 표준**\n\n- Object-Relational Mapping(객체 관계 매핑)\n  - 객체는 객체대로 설계\n  - 관계형 데이터베이스는 관계형 데이터베이스대로 설계\n  - ORM 프레임워크가 중간에서 매핑\n\n\n## JPA를 사용하는 이유\n\n- SQL 중심 개발에서 객체 중심으로 개발\n  - ORM이 중간에서 문제 해결\n  - 자바 객체 컬렉션 조회하듯 던지면 된다.\n- 생산성\n  - SQL 반복 작업을 하지 않음\n- 유지보수\n  - JPA가 직접 SQL 작업을 수행하기에 유지보수 측면에서 장점이 있음\n- 패러다임의 불일치 해결\n- 데이터 접근 추상화와 벤더 독립성\n  - JPA는 추상화된 데이터 접근 계층을 제공해 특정 벤더에 종속적이지 않음\n  - 어떤 DB를 사용하는 지 설정만 해주면 됨\n\n\n## 유지보수\n- JPA 필드만 추가해주면 SQL은 JPA가 처리해준다.\n- 트랜젝션 안에서 조회후 변경 진행하면 트랜젝션 변경 시점에서 업데이트 쿼리가 진행되며 커밋이 진행된다.\n```java\npublic class Member {\n\tprivate String memberId;\n\tprivate String name;\n\tprivate String tel;  // 추가된 필드\n}\n```\n\n"},{"excerpt":"Monolithic 애플리케이션을 하나의 소프트웨어 안에 포함시켜 개발하는 방식 모든 업무 로직이 하나의 애플리케이션 형태로 패키지 되어 서비스 서비스 하나가 수정되면 전체가 재 패키징 되어 배포 애플리케이션에서 사용하는 데이터가 한곳에 모여 참조되어 서비스 되는 형태 MSA - Micro Service Aplication 복잡한 애플리케이션을 독립적인 …","fields":{"slug":"/250120_VS/"},"frontmatter":{"date":"January 20, 2025","title":"🍃 Monolithic VS MSA","tags":["MSA","Microservice","Monolithic"]},"rawMarkdownBody":"\n## Monolithic\n\n> 애플리케이션을 하나의 소프트웨어 안에 포함시켜 개발하는 방식\n>\n\n- 모든 업무 로직이 하나의 애플리케이션 형태로 패키지 되어 서비스\n  - 서비스 하나가 수정되면 전체가 재 패키징 되어 배포\n- 애플리케이션에서 사용하는 데이터가 한곳에 모여 참조되어 서비스 되는 형태\n\n<br>\n\n---\n\n## MSA - Micro Service Aplication\n\n> 복잡한 애플리케이션을 독립적인 작은 서비스들로 나누어 개발, 배포 및 유지보수하는 방식\n>\n\n- 서비스가 분리되어 있어 전체가 다운되는 상황이 없음.\n- 서비스 간 resource API  (HTTP 통신)\n- 최소한의 중앙 집중 식 관리가 되어야 한다.\n- 서로 다른 언어, 저장기술을 사용할 수 있음\n  - 서비스 특색에 맞게 작업 진행이 가능하다."},{"excerpt":"Issue 추가 기능 개발로 FEATURE_A 브랜치를 DEV에 Rebase + Merge 후 QA 요청 QA가 완료되기 전에 동일한 파일에서 추가 수정 사항 발생 해당 수정 사항을 FEATURE_B 브랜치에서 DEV에 Rebase + Merge Rebase 과정에서 FEATURE_A의 코드가 운영 서버에 반영되면 에러 발생 가능성이 있어 일부 코드 누락…","fields":{"slug":"/250115_git-issue/"},"frontmatter":{"date":"January 16, 2025","title":"🐙 Git-flow issue","tags":["git","git flow"]},"rawMarkdownBody":"\n## Issue\n\n<br/>\n\n- 추가 기능 개발로 FEATURE_A 브랜치를 DEV에 **Rebase + Merge** 후 QA 요청\n- QA가 완료되기 전에 동일한 파일에서 추가 수정 사항 발생\n- 해당 수정 사항을 FEATURE_B 브랜치에서 DEV에 **Rebase + Merge**\n    - Rebase 과정에서 FEATURE_A의 코드가 운영 서버에 반영되면 에러 발생 가능성이 있어 일부 코드 누락\n        - **<span style=\"color:red;\">결과적으로 기존 코드 일부가 누락되는 문제 발생</span>**\n\n<br/>\n\n> 추후 신규 개발 및 유지보수 과정에서 유사한 문제가 반복될 가능성이 높아 Git-flow 전략을 재점검하게 되었습니다."},{"excerpt":"형상 관리 이번에 저희 회사에서는, 신규 개발을 앞두고 형상 관리가 이루어지지 않았던 기존 환경에서 GitHub를 활용한 체계적인 형상 관리 시스템을 도입하게 되었습니다. Git flow 전략 1. BRANCH 저희 팀은 Branch를 , ,  이렇게 3가지를 가져가기로 했습니다.  MAIN : 실제 서버에 배포되는 브랜치 DEV : 테스트 서버에 배포되…","fields":{"slug":"/250116_git-flow/"},"frontmatter":{"date":"January 15, 2025","title":"🐙 Git-flow","tags":["git","git flow"]},"rawMarkdownBody":"\n> **형상 관리**\n>\n\n이번에 저희 회사에서는,\n\n신규 개발을 앞두고 형상 관리가 이루어지지 않았던 기존 환경에서 **GitHub를 활용한 체계적인 형상 관리 시스템을 도입**하게 되었습니다.\n\n## Git flow 전략\n\n### 1. BRANCH\n\n저희 팀은 Branch를 `MAIN`, `DEV`, `FEATURE` 이렇게 3가지를 가져가기로 했습니다.\n\n![BRANCH](./git-feature.png)\n\n- MAIN : 실제 서버에 배포되는 브랜치\n- DEV : 테스트 서버에 배포되는 브랜치\n- FEATURE : 기능 구현을 위한 브랜치( 로컬 작업 )\n\n### 2. FLOW\n\n전체적인 흐름은 rebase를 통해 Git 히스토리를 단순하고 직관적으로 유지할 수 있도록 하는 것이 목표 입니다.\n\n<br/>\n\n![git_flow](./git-rebase-policy-2.png)\n\n<br/>\n\n- 불필요한 병합 커밋 없이 일관된 선형 히스토리 유지\n- 브랜치 병합 전에 충돌을 미리 해결 가능\n- `git pull --rebase`를 활용해 최신 코드 반영"},{"excerpt":"Cloud Native Application 개발을 위한 12가지 원칙 1.  CODEBASE 코드베이스는 Git 저장소 하나로 관리 여러 환경(개발/테스트/운영)은 동일한 코드에서 분기(branch)하여 관리 한 코드베이스 = 하나의 애플리케이션 2.  DEPENDENCY 애플리케이션 내에서 종속성을 해결 컨테이너화된 환경에서는 의존성이 포함된 Dock…","fields":{"slug":"/microservice_post_2/"},"frontmatter":{"date":"January 13, 2025","title":"🍃 12 Factors","tags":["MSA","12 Factors"]},"rawMarkdownBody":"\n> **Cloud Native Application 개발을 위한 12가지 원칙**\n>\n\n## 1.  CODEBASE\n\n- 코드베이스는 **Git 저장소 하나로 관리**\n- 여러 환경(개발/테스트/운영)은 **동일한 코드에서 분기(branch)하여 관리**\n- 한 코드베이스 = 하나의 애플리케이션\n\n## 2.  DEPENDENCY\n\n- 애플리케이션 내에서 종속성을 해결\n- 컨테이너화된 환경에서는 **의존성이 포함된 Docker 이미지 사용**\n\n## 3. CONFIGURATIONS\n\n- 시스템 코드 외부에서 구성 관리 도구를 통해 마이크로 서비스에 필요한 작업들을 제어\n- 환경 변수(ENV)로 설정 관리\n\n## 4. LINKABLE BACKING SERVICES\n\n- DB, Redis, S3 등의 백엔드 서비스는 독립적인 리소스로 취급( 의존성 제거 )\n- 언제든지 교체 가능하도록 **환경 변수 기반 연결**\n\n## 5. STAGES OF CREATION\n\n- 빌드, 릴리즈, 실행 단계를 분리하여 배포\n- 각각 고유한 아이디를 태그로 가져야함\n- 롤백 기능 제공\n- CI / CD 를 통한 자동화 구축 필요\n\n## 6. STATELESS PROCESSES\n\n- 각각의 마이크로 서비스는 분리된 채 독립적으로 운영\n- 필요한 자원이 있다면 캐시, 데이터 저장소를 통해 외부와 교환\n\n## 7. PORT BINDING\n\n- 각 서비스가 HTTP 요청을 직접 처리하며, 필요에 따라 Nginx나 API Gateway를 통해 라우팅만 처리\n- 마이크로서비스는 **독립적인 프로세스**로 실행되며, 각 서비스가 고유한 포트를 바인딩\n\n## 8. CONCURRENCY\n\n- 마이크로서비스 + 컨테이너 조합\n- Kubernetes, Docker Swarm을 사용한 **자동 확장 지원**\n- 단일 애플리케이션 인스턴스 대신 여러 인스턴스를 실행.\n\n## 9. DISPOSABILITY\n\n- 애플리케이션은 몇 초 내로 시작 가능해야 하며, SIGTERM 신호를 받아 정상 종료 가능해야 함\n- 서비스 인스턴스 삭제가 가능해야함\n\n## 10. DEVELOPMENT & PRODUCTION PARITY\n\n- 개발 단계와 프로덕션 단계를 구분\n- 개발, 스테이징, 운영 환경 간의 격차를 줄이고, 최대한 유사한 환경에서 애플리케이션을 개발, 테스트 및 배포\n\n## 11. LOGS\n\n- 애플리케이션은 로그를 파일로 관리하지 않고, 표준 출력으로 전달\n- 애플리케이션 로직과 분리되어 애플리케이션이 실행되지 않는 상태여도 로그는 정상 작동 해야함\n- 모니터링 시스템을 통해 장기적으로 보관된 로그를 분석\n\n## 12. ADMIN PROCESSES FOR EVENTUAL PROCESSES\n\n- 관리 프로세스는 애플리케이션과 동일한 환경에서 실행\n- 관리 작업은 운영 중인 애플리케이션과 분리된 임시 작업으로, 데이터 마이그레이션, 일회성 스크립트 실행, 대량 데이터 처리 등이 포함\n- Eventual Processes는 특정 시점에 실행되며, 이벤트 기반의 비동기 또는 일회성 프로세스\n    - 데이터베이스 마이그레이션\n    - 백그라운드 데이터 처리\n    - 비동기 이메일 전송\n    - 대량 파일 처리 (예: AWS S3와 연동된 작업)"},{"excerpt":"클라우드 환경에서 최적화되어 동작하도록 설계된 애플리케이션 컨테이너, 마이크로서비스, CI/CD, DevOps, 동적 오케스트레이션(Kubernetes) 등을 활용하여 유연성과 확장성을 극대화하는 것이 특징 특징 1. 지속적인 통합, CI (Continuous Integration) 통합 서버, 소스관리 (SCM), 빌드 도구, 테스트 도구 ex ) Je…","fields":{"slug":"/microservice_post_1/"},"frontmatter":{"date":"January 13, 2025","title":"🍃 Cloud Native Application","tags":["MSA","Cloud Native Application"]},"rawMarkdownBody":"\n> **클라우드 환경에서 최적화되어 동작하도록 설계된 애플리케이션**\n>\n- **컨테이너, 마이크로서비스, CI/CD, DevOps, 동적 오케스트레이션(Kubernetes)** 등을 활용하여 유연성과 확장성을 극대화하는 것이 특징\n\n## 특징\n\n### 1. 지속적인 통합, CI (Continuous Integration)\n  - 통합 서버, 소스관리 (SCM), 빌드 도구, 테스트 도구\n  - ex ) Jenkins, Team CI, Travis Ci\n\n### 2. 지속적 배포, CD\n  - Continuous Delivery\n    - 패키지화 된 결과물 실행 환경에 수동 반영\n  - Continuous Deplyment\n    - 자동 배포\n  - Pipe line\n\n### 3. 카나리 배포와 블루그린 배포\n  - 카나리 배포(Canary Deployment)\n    - 새 애플리케이션을 소수에게 배포한 후 안정성이 확보되면 점진적으로 모든 사용자에게 배포\n  - 블루-그린 배포(Blue-Green Deployment)\n    - 두 개의 환경(Blue: 기존 버전, Green: 새로운 버전)을 동시에 운영하여 새로운 버전이 준비되면 한번에 모든 트래픽을 이동시키는 방식\n    - rollback 가능\n\n### 4. DevOps\n  - 소프트웨어 개발(Development)과 운영(Operations)을 통합하는 문화 및 방법론\n  - **자동화**, **협업**, 지속적 통합/배포(CI/CD)를 통해 **빠르고 안정적인 소프트웨어 개발 및 운영을 목표**\n\n### 5. Container 가상화\n  - 운영체제(OS) 수준에서 애플리케이션을 격리하고 실행하는 가상화 기술\n  - 하이퍼바이저 기반 VM(Virtual Machine) 보다 **더 가볍고 빠르며, 확장성이 뛰어남**"},{"excerpt":"Cloud Native Architecture(클라우드 네이티브 아키텍처)란 클라우드 환경을 최대한 활용하도록 설계된 소프트웨어 아키텍처 패턴 확장 가능한 아키텍처 시스템의 수평적 확장에 유연 확장된 서버로 시스템의 부하 분산, 가용성 보장 시스템 또는, 서비스 애플리케이션 단위의 패키지 (컨테이너 기반 패키지) 모니터링 탄력적 아키텍처 서비스 생성 - …","fields":{"slug":"/microservice_post/"},"frontmatter":{"date":"January 13, 2025","title":"🍃 Cloud Native Architecture","tags":["MSA","Cloud Native Architecture"]},"rawMarkdownBody":"\n> Cloud Native Architecture(클라우드 네이티브 아키텍처)란 **클라우드 환경을 최대한 활용**하도록 설계된 소프트웨어 아키텍처 패턴\n>\n\n- 확장 가능한 아키텍처\n    - 시스템의 수평적 확장에 유연\n    - 확장된 서버로 시스템의 부하 분산, 가용성 보장\n    - 시스템 또는, 서비스 애플리케이션 단위의 패키지 (컨테이너 기반 패키지)\n    - 모니터링\n- 탄력적 아키텍처\n    - 서비스 생성 - 통합 - 배포, 비즈니스 환경 변화에 대응 시간 단축\n        - 자동 CI / CD\n    - 분할 된 서비스 구조\n    - 무상태 통신 프로토콜\n    - 서비스의 추가와 삭제 자동으로 감지\n    - 변경된 서비스 요청에 따라 사용자 요청 처리 (동적 처리)\n- 장애 격리 (Fault isolation)\n    - 특정 서비스에 오류가 발생해도 다른 서비스에 영향 주지 않음"},{"excerpt":"풀이 시간 복잡도 O(N * W)  총 단어 개수(N) 중 해당 길이(W) 만큼 연산 발생","fields":{"slug":"/baekjoon_test2/"},"frontmatter":{"date":"January 13, 2025","title":"🐶 백준 알고리즘 - 1316 그룹 단어 체커","tags":["Backjoon","Algorithm","구현","문자열"]},"rawMarkdownBody":"\n## 풀이\n<br/>\n\n```java\nimport java.io.*;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\n        int number = Integer.parseInt(br.readLine()); // 단어 수\n        int count = 0; // 그룹 단어 수\n\n        for (int i = 0; i < number; i++) {\n            String input = br.readLine();\n            List<Character> charList = input.chars()\n                    .mapToObj(c -> (char)c)\n                    .collect(Collectors.toList());\n\n            if (groupWord(charList)) {\n                count++;\n            }\n        }\n        bw.write(count + \"\\n\");\n\n        bw.flush();\n        br.readLine();\n        bw.close();\n\n    }\n\n    // 그룹 단어 여부\n    public static boolean groupWord(List<Character> charList) {\n        Set<Character> seen = new HashSet<>(); // 등장한 문자를 저장하는 Set\n        char prev = charList.get(0); // 첫 번째 문자 저장\n\n        for (char c : charList) {\n            if (seen.contains(c) && prev != c) { // 이미 등장한 문자지만 연속되지 않은 경우\n                return false;\n            }\n            seen.add(c); // 현재 문자 저장\n            prev = c; // 이전 문자 업데이트\n        }\n        return true;\n    }\n}\n```\n\n### 시간 복잡도\n- O(N * W) \n  - 총 단어 개수(N) 중 해당 길이(W) 만큼 연산 발생\n\n[^1]: https://www.acmicpc.net/problem/1316\n\n"},{"excerpt":"풀이 시간 복잡도 O(N)","fields":{"slug":"/baekjoon_test/"},"frontmatter":{"date":"January 12, 2025","title":"🐶 백준 알고리즘 - 1152 단어의 개수","tags":["Backjoon","Algorithm","구현","문자열"]},"rawMarkdownBody":"\n## 풀이\n<br/>\n\n```java\nimport java.io.*;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        \n        String text = br.readLine().trim(); // 입력받고 앞뒤 공백 제거\n        StringTokenizer st = new StringTokenizer(text, \" \"); // 공백 기준으로 토큰화\n\n        bw.write(String.valueOf(st.countTokens())); // 토큰 개수 출력\n        \n        bw.flush(); // 출력 버퍼 비우기\n        br.close(); // 자원 해제\n        bw.close(); // 자원 해제\n    }\n}\n```\n\n### 시간 복잡도\n- O(N)\n\n[^1]: https://www.acmicpc.net/problem/1152\n\n"},{"excerpt":"1. 클래스명은 Main, 이와같이 클래스명을 Main으로 두고 작성한다 2. Main 함수에서 바로 작성 시, 모든것은 static으로 선언 후 작성한다. main문 자체가 static 함수 이므로 내부에서 사용하는 전역변수 및 모든 함수 또한 static 이어야 한다. 3. 입력 값을 받을 땐 Scanner 보단 BufferedReader Scanne…","fields":{"slug":"/baekjoon_tips/"},"frontmatter":{"date":"January 11, 2025","title":"🐶 백준 알고리즘 팁","tags":["Backjoon","Algorithm"]},"rawMarkdownBody":"\n## 1. 클래스명은 Main,\n\n```java\npublic class Main {\n\t\n}\n```\n\n이와같이 클래스명을 Main으로 두고 작성한다\n\n## 2. Main 함수에서 바로 작성 시, 모든것은 static으로 선언 후 작성한다.\n\n```java\npublic class Main {\n\tprivate static int max = 0;\n\tprivate static int n, k;\n\t\n\tprivate static void dfs(int cnt, int num) {\n\t\n\t}\n}\n```\n\nmain문 자체가 static 함수 이므로 내부에서 사용하는 전역변수 및 모든 함수 또한 static 이어야 한다.\n\n## 3. 입력 값을 받을 땐 Scanner 보단 BufferedReader\n\n```java\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tpublic void solution() throws Exeption {\n\t\t BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t int n = Integer.parseInt(br.readLine());\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().solution();\n\t}\n}\n```\n\nScanner는 내부적으로 다음 입력값을 찾을 때 정규식을 사용해 속도가 느리다.\n\n## 4.문자열 구분\n\nString 문자열 구분 시 split()보단 StringTokenizer를 사용하는 것이 속도가 더 빠르다.\n\n```java\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    public void solution() throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        \n        for (int i = 0; i < n; i++) {\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            int s = Integer.parseInt(st.nextToken());\n\n            for (int j = 0; j < s; j++) {\n                int data = Integer.parseInt(st.nextToken());\n                System.out.println(data);\n            }\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        new Main().solution();\n    }\n}\n\n```\n\n위와 같이 BufferedReader와 StringTokenizer로 입력받는다면 빠르게 입력받을 수 있다.\n\n## 5. 입력을 위한 클래스는 하나만\n\n- System.in이 들어간 클래스는 단 하나만 생성하는 것이 좋다.\n\n## 6. 출력 시 System.out.printIn() 보다 BufferedWriter가 빠르다\n\n```java\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    public void solution() throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\n        int n = Integer.parseInt(br.readLine());\n\n        for (int i = 0; i < n; i++) {\n            StringTokenizer st = new StringTokenizer(br.readLine()); // 토큰화\n            int s = Integer.parseInt(st.nextToken());\n\n            for (int j = 0; j < s; j++) {\n                int data = Integer.parseInt(st.nextToken());\n                bw.write(String.valueOf(data)); // 출력\n                bw.newLine(); // 줄바꿈            }\n        }\n\n        bw.flush(); // 출력 버퍼 비우기\n        br.close(); // 자원 해제\n        bw.close(); // 자원 해제\n    }\n\n    public static void main(String[] args) throws Exception {\n        new Main().solution();\n    }\n}\n\n```"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}